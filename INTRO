XP Mockery - Introduction

1) Preface

* The mock library is still under development and does not yet implement 
  all the features grown-up mocking frameworks do. So here is a feature list
  and a list of stuff that is not yet implemented (in order of importance)

* Implemented:
  1) generating mocks/stubs (all methods return null by default)
  2) return values of mocks/stubs
  3) repetions of returns
 
* Not implemented:
  2) Method argument matching
  3) Behaviour verification
  4) Execution order verification
  5) Strict  mocks (unsatisfied expectation)
  6) Rewinding the replay state
  
* The mock library uses a heavily refactored version of the lang.reflect.Proxy class,
  which is not part of the official XP-Framework yet. Thus please use with caution, it 
  might break EVERYTHING.

* You can find the example classes in the xp-forge repository svn+ssh://svn.xp-framework.net/home/svn/xpforge/trunk/experiments/arena/mocks/tests/tutorial

2) Usage

* Creating a mock.
 
  - Consider service MyService that depends on an IContext which let's you check 
    permissions and read some data:
  
  
  - IContext.class.php
	interface IContext {
	  function getData();
	  function hasPermission($permission);
	}
	
	
  - MyService.class.php
	uses('tutorial.IContext');
	class MyService {
	  private $context= null;
	  private $secret="abracadabra!";
    
	  /*
	   * Constructor
	   *
	   * @param IContext context
	   */
	  public function __construct($context) {
	    $this->context=$context;
	  }

      public function readContextData() {
        return $this->context->getData();
      }

	  public function getSecretStuff() {
		if($this->context->hasPermission("rt=foo,rn=bar"))
	      return $this->secret;
	    else
        throw new IllegalAccessException("Netter Versuch, Robert!");
	  }
	}
	
  - now if we want to test the MyService class we have to construct an instance.
	Probably we would even write a unit test to verify that the construction works:
	  
	    #[@test]
		public function canCreate() {
		  new MyService(null);
		}
	
  - to create a MyService instance we need an IContext, but in this case it is 
	absolutely irrelevant what the context is, so we just pass null
	  
  - when it comes to testing the readContextData method, this won't work as we need a working context.
	
		#[@test]
		public function can_call_readContextData() {
		  $fixture= new MyService(null);
		  $fixture->readContextData();
		}

  - so we need to initialize an actual IContext. However we might have no concrete class which implements
	IContext and is easy to instantiate, i.e. without resolving other dependencies like 
	connecting to databases/LDAPs, reading ini-files, configuring stuff etc.
    
  - here is where mocks come into play. We just tell the mockery to create an object which implements the IContext interface.
	  
		#[@test]
		public function can_call_readContextData() {
		  $mockery=new Mockery();
		  $context= $mockery->createMock('tutorial.IContext'); //create an IContext
		  $mockery->replayAll(); //ignore this for a moment.
		  
		  //here comes the actual test
		  $fixture= new MyService($context);
		  $fixture->readContextData(); //returns null
		}
	
* Return Values
  - by default each method of a mocked object returns null. However we might need the dependent object to return actual stuff.
	For example to completely test the method getSecretStuff, we need to check two cases. 
	  1) $this->context->hasPermission("rt=foo,rn=bar") returns TRUE;
	  2) $this->context->hasPermission("rt=foo,rn=bar") returns FALSE;
	  
  - to accomplish that we just tell the context to return the value we want it to.
		$context= $mockery->createMock('tutorial.IContext');
		$context->hasPermission(null)->returns(TRUE); //tell hasPermission to return TRUE
	  
  - [ as argument matching is not implemented yet, we just pass null ]
	
  - so now we can write the following test:
	    #[@test]
		public function getSecretStuff_works_withPermissions() {
		  $mockery=new Mockery();
		  $context= $mockery->createMock('tutorial.IContext');
		  $context->hasPermission(null)->returns(TRUE); //tell hasPermission to return TRUE
		  $mockery->replayAll();

		  $fixture= new MyService($context);
		  $this->assertEquals("abracadabra!", $fixture->getSecretStuff());
		}
	 
  - to test the exception case (no permissions) we use the following test:
    #[@test, @expect('lang.IllegalAccessException')]
		public function getSecretStuff_throwsException_whithoutPermissions() {
		  $mockery=new Mockery();
		  $context= $mockery->createMock('tutorial.IContext');
		  $context->hasPermission(null)->returns(FALSE); //no permissions
		  $mockery->replayAll();

		  $fixture= new MyService($context);
		  $this->assertEquals("abracadabra!", $fixture->getSecretStuff());
		}

* Repetitions
  - note that the defintion of the return value is only valid for one call
		$context->hasPermission(null)->returns(TRUE);
		$mockery->replayAll();
		
		$context->hasPermission(null); //first call -> TRUE
		$context->hasPermission(null); //second call -> null
	
  - thus if you expect that hasPermission is called twice, you need to define the return values 
	for both calls, i.e.
	  
		$context->hasPermission(null)->returns(TRUE); //first call
		$context->hasPermission(null)->returns(FALSE); //second call
		$mockery->replayAll();
		
		$context->hasPermission(null); //first call -> TRUE
		$context->hasPermission(null); //second call -> FALSE 
	
  - a third call to hasPermission would again yield null
	
  - if you want the same value to be returned a specific number of times you can use ->repeat($numOfRepetions) 
    or  ->repeatAny() to repeat the same value permanently
	
		
		$context->hasPermission(null)->returns(TRUE)->repeat(2); //first call
		$mockery->replayAll();		
	
		$context->hasPermission(null); //first call -> TRUE
		$context->hasPermission(null); //second call -> TRUE //repeat
		$context->hasPermission(null); //third call -> NULL


* Record/Replay/Verfiy
  - now about that $mockery->replayAll() call. This is part of the Record/Replay/Verfiy paradigm,
    that is used for the mocking framework. In the Record phase you tell your mocks how they should
    behave. With replayAll you activate the Replay Phase. Now when you call methods on your mocks
    they will actually return the stuff you have recorded. In Verification phase (not implemented yet)
    you check whether your recorded expectations are fulfilled.
	
	  
  - that's it for now.
	
* Happy Mocking!